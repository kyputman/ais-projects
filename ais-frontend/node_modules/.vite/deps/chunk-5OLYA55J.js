// node_modules/effector/effector.mjs
function e(e2, t2) {
  for (let r2 in e2)
    t2(e2[r2], r2);
}
function t(e2, t2) {
  e2.forEach(t2);
}
function r(e2, t2) {
  if (!e2)
    throw Error(t2);
}
function n(e2, t2) {
  let r2 = V(e2).meta || {};
  he = { id: V(e2).id, parent: he, value: e2, template: r2.template || be(), sidRoot: r2.sidRoot || he && he.sidRoot, meta: r2 };
  try {
    return t2();
  } finally {
    ye("region"), he = U(he);
  }
}
function a({ node: e2 = [], from: r2, source: n2, parent: a2 = r2 || n2, to: i2, target: o2, child: l2 = i2 || o2, scope: s2 = {}, meta: f2 = {}, family: u2 = { type: "regular" }, regional: d2 } = {}) {
  let c2 = Se(a2), p2 = Se(u2.links), m2 = Se(u2.owners), g2 = [];
  t(e2, (e3) => e3 && le(g2, e3));
  let h2 = { id: pe(), seq: g2, next: Se(l2), meta: f2, scope: s2, family: { type: u2.type || "crosslink", links: p2, owners: m2 } };
  return t(p2, (e3) => le(L(e3), h2)), t(m2, (e3) => le(T(e3), h2)), t(c2, (e3) => le(e3.next, h2)), d2 && he && we(W(he), [h2]), h2;
}
function i(e2, r2, n2) {
  let a2, i2 = at, o2 = null, l2 = et;
  if (e2.target && (r2 = e2.params, n2 = e2.defer, a2 = e2.meta, i2 = "page" in e2 ? e2.page : i2, e2.stack && (o2 = e2.stack), l2 = G(e2) || l2, e2 = e2.target), l2 && et && l2 !== et && (et = null), Array.isArray(e2))
    for (let t2 = 0; t2 < e2.length; t2++)
      Qe("pure", i2, V(e2[t2]), o2, r2[t2], l2, a2);
  else
    Qe("pure", i2, V(e2), o2, r2, l2, a2);
  if (n2 && !tt)
    return;
  let s2, f2, u2, d2, c2, p2, m2 = { isRoot: tt, currentPage: at, scope: et, isWatch: rt, isPure: nt };
  tt = 0;
  e:
    for (; d2 = Ke(); ) {
      let { idx: e3, stack: r3, type: n3 } = d2;
      u2 = r3.node, at = c2 = r3.page, et = G(r3), c2 ? p2 = c2.reg : et && (p2 = et.reg);
      let a3 = !!c2, i3 = !!et, o3 = { fail: 0, scope: u2.scope };
      s2 = f2 = 0;
      for (let t2 = e3; t2 < u2.seq.length && !s2; t2++) {
        let l3 = u2.seq[t2];
        if (l3.order) {
          let { priority: a4, barrierID: i4 } = l3.order, o4 = i4 ? c2 ? `${c2.fullID}_${i4}` : i4 : 0;
          if (t2 !== e3 || n3 !== a4) {
            i4 ? Ze.has(o4) || (Ze.add(o4), Xe(t2, r3, a4, i4)) : Xe(t2, r3, a4);
            continue e;
          }
          i4 && Ze.delete(o4);
        }
        switch (l3.type) {
          case "mov": {
            let e5, t3 = l3.data;
            switch (t3.from) {
              case _:
                e5 = W(r3);
                break;
              case "a":
              case "b":
                e5 = r3[t3.from];
                break;
              case "value":
                e5 = t3.store;
                break;
              case "store":
                if (p2 && !p2[t3.store.id])
                  if (a3) {
                    let e6 = st(c2, t3.store.id);
                    r3.page = c2 = e6, e6 ? p2 = e6.reg : i3 ? (pt(et, t3.store, 0, 1, t3.softRead), p2 = et.reg) : p2 = void 0;
                  } else
                    i3 && pt(et, t3.store, 0, 1, t3.softRead);
                e5 = Be(p2 && p2[t3.store.id] || t3.store);
            }
            switch (t3.to) {
              case _:
                r3.value = e5;
                break;
              case "a":
              case "b":
                r3[t3.to] = e5;
                break;
              case "store":
                ut(c2, et, u2, t3.target).current = e5;
            }
            break;
          }
          case "compute":
            let e4 = l3.data;
            if (e4.fn) {
              rt = "watch" === J(u2, "op"), nt = e4.pure;
              let t3 = e4.safe ? (0, e4.fn)(W(r3), o3.scope, r3) : mt(o3, e4.fn, r3);
              e4.filter ? f2 = !t3 : r3.value = t3, rt = m2.isWatch, nt = m2.isPure;
            }
        }
        s2 = o3.fail || f2;
      }
      if (ft && ft(r3, o3), !s2) {
        let e4 = W(r3), n4 = G(r3);
        if (t(u2.next, (t2) => {
          Qe("child", c2, t2, r3, e4, n4);
        }), n4) {
          J(u2, "needFxCounter") && Qe("child", c2, n4.fxCount, r3, e4, n4), J(u2, "storeChange") && Qe("child", c2, n4.storeChange, r3, e4, n4), J(u2, "warnSerialize") && Qe("child", c2, n4.warnSerializeNode, r3, e4, n4);
          let a4 = n4.additionalLinks[u2.id];
          a4 && t(a4, (t2) => {
            Qe("child", c2, t2, r3, e4, n4);
          });
        }
      }
    }
  tt = m2.isRoot, at = m2.currentPage, et = G(m2);
}
function o(t2, r2 = "combine") {
  let n2 = r2 + "(", a2 = "", i2 = 0;
  return e(t2, (e2) => {
    i2 < 25 && (null != e2 && (n2 += a2, n2 += X(e2) ? Q(e2).fullName : e2.toString()), i2 += 1, a2 = ", ");
  }), n2 + ")";
}
function l(e2, t2) {
  e2.shortName = t2, Object.assign(Q(e2), s(t2, U(e2)));
}
function s(e2, t2) {
  let r2, n2, a2 = e2;
  if (t2) {
    let a3 = Q(t2);
    0 === e2.length ? (r2 = a3.path, n2 = a3.fullName) : (r2 = a3.path.concat([e2]), n2 = 0 === a3.fullName.length ? e2 : a3.fullName + "/" + e2);
  } else
    r2 = 0 === e2.length ? [] : [e2], n2 = e2;
  return { shortName: a2, fullName: n2, path: r2 };
}
function f(e2, t2) {
  let r2 = t2 ? e2 : e2[0];
  je(r2);
  let n2 = r2.or, a2 = r2.and;
  if (a2) {
    let r3 = t2 ? a2 : a2[0];
    if (xe(r3) && "and" in r3) {
      let r4 = f(a2, t2);
      e2 = r4[0], n2 = { ...n2, ...r4[1] };
    } else
      e2 = a2;
  }
  return [e2, n2];
}
function u(e2, ...t2) {
  let r2 = be();
  if (r2) {
    let n2 = r2.handlers[e2];
    if (n2)
      return n2(r2, ...t2);
  }
}
function d(e2, t2) {
  let r2 = gt({ or: t2, and: "string" == typeof e2 ? { name: e2 } : e2 }), n2 = (e3, ...t3) => (se(!J(n2, "derived"), "call of derived event", "createEvent"), se(!nt, "unit call from pure function", "operators like sample"), at ? ((e4, t4, r3, n3) => {
    let a2 = at, i2 = null;
    if (t4)
      for (i2 = at; i2 && i2.template !== t4; )
        i2 = U(i2);
    lt(i2);
    let o3 = e4.create(r3, n3);
    return lt(a2), o3;
  })(n2, o2, e3, t3) : n2.create(e3, t3)), o2 = be(), l2 = Object.assign(n2, { graphite: a({ meta: $t(r2.actualOp || "event", n2, r2), regional: 1 }), create: (e3) => (i({ target: n2, params: e3, scope: et }), e3), watch: (e3) => xt(n2, e3), map: (e3) => jt(n2, P, e3, [Ve()]), filter: (e3) => jt(n2, "filter", e3.fn ? e3 : e3.fn, [Ve(qe, 1)]), filterMap: (e3) => jt(n2, "filterMap", e3, [Ve(), Pe((e4) => !$e(e4), 1)]), prepend(e3) {
    let t3 = d("* → " + n2.shortName, { parent: U(n2) });
    return u("eventPrepend", V(t3)), wt(t3, n2, [Ve()], "prepend", e3), zt(n2, t3), t3;
  } });
  return null != r2 && r2.domain && r2.domain.hooks.event(l2), ye(l2.graphite), l2;
}
function c(e2, n2, a2, i2) {
  return Me(a2, n2, "first argument"), r(ze(i2), "second argument should be a function"), se(!J(e2, "derived"), `${n2} in derived store`, `${n2} in store created via createStore`), t(Array.isArray(a2) ? a2 : [a2], (t2) => {
    e2.off(t2), H(e2).set(t2, kt(Ct(t2, e2, "on", Oe, i2)));
  }), e2;
}
function p(e2, n2) {
  let o2 = gt(n2), l2 = Te(e2), s2 = d({ named: "updates", derived: 1 });
  u("storeBase", l2);
  let f2 = l2.id, m2 = { subscribers: /* @__PURE__ */ new Map(), updates: s2, defaultState: e2, stateRef: l2, getState() {
    let e3, t2 = l2;
    if (at) {
      let t3 = at;
      for (; t3 && !t3.reg[f2]; )
        t3 = U(t3);
      t3 && (e3 = t3);
    }
    return !e3 && et && (pt(et, l2, 1), e3 = et), e3 && (t2 = e3.reg[f2]), Be(t2);
  }, setState: (e3) => i({ target: m2, params: e3, defer: 1, scope: et }), reset: (...e3) => (t(e3, (e4) => c(m2, ".reset", e4, () => m2.defaultState)), m2), on: (e3, t2) => c(m2, ".on", e3, t2), off(e3) {
    let t2 = H(m2).get(e3);
    return t2 && (t2(), H(m2).delete(e3)), m2;
  }, map(e3, t2) {
    let r2, n3;
    xe(e3) && (r2 = e3, e3 = e3.fn), se($e(t2), "second argument of store.map", "updateFilter");
    let a2 = m2.getState();
    be() ? n3 = null : $e(a2) || (n3 = e3(a2, t2));
    let i2 = p(n3, { name: `${m2.shortName} → *`, derived: 1, and: r2 }), o3 = Ct(m2, i2, P, Ie, e3);
    return We(B(i2), { type: P, fn: e3, from: l2 }), B(i2).noInit = 1, u("storeMap", l2, o3), i2;
  }, watch(e3, t2) {
    if (!t2 || !X(e3)) {
      let t3 = xt(m2, e3);
      return u("storeWatch", l2, e3) || e3(m2.getState()), t3;
    }
    return r(ze(t2), "second argument should be a function"), e3.watch((e4) => t2(m2.getState(), e4));
  } }, g2 = $t("store", m2, o2), h2 = m2.defaultConfig.updateFilter;
  m2.graphite = a({ scope: { state: l2, fn: h2 }, node: [Pe((e3, t2, r2) => (r2.scope && !r2.scope.reg[l2.id] && (r2.b = 1), e3)), _e(l2), Pe((e3, t2, { a: r2, b: n3 }) => !$e(e3) && (e3 !== r2 || n3), 1), h2 && Ve(Ie, 1), De({ from: _, target: l2 })], child: s2, meta: { ...g2, defaultState: e2 }, regional: 1 });
  let y2 = J(m2, "serialize"), b2 = J(m2, "derived"), v2 = "ignore" === y2, k2 = !y2 || v2 ? 0 : y2, w2 = J(m2, "sid");
  return w2 && (K(m2, "storeChange", 1), l2.sid = w2, k2 && (l2.meta = { ...null == l2 ? void 0 : l2.meta, serialize: k2 })), w2 || v2 || b2 || K(m2, "warnSerialize", 1), r(b2 || !$e(e2), "current state can't be undefined, use null instead"), we(m2, [s2]), null != o2 && o2.domain && o2.domain.hooks.store(m2), b2 || (m2.reinit = d({ named: "reinit" }), m2.reset(m2.reinit)), ye(m2.graphite), m2;
}
function m(...e2) {
  let t2, n2, a2;
  [e2, a2] = f(e2);
  let i2, o2, l2, s2 = e2[e2.length - 1];
  if (ze(s2) ? (n2 = e2.slice(0, -1), t2 = s2) : n2 = e2, 1 === n2.length) {
    let e3 = n2[0];
    Z(e3) || (i2 = e3, o2 = 1);
  }
  if (!o2 && (i2 = n2, t2)) {
    l2 = 1;
    let e3 = t2;
    t2 = (t3) => e3(...t3);
  }
  return r(xe(i2), "shape should be an object"), Mt(Array.isArray(i2), !l2, i2, a2, t2);
}
function g(...e2) {
  return se(0, "createStoreObject", "combine"), m(...e2);
}
function h() {
  let e2 = {};
  return e2.req = new Promise((t2, r2) => {
    e2.rs = t2, e2.rj = r2;
  }), e2.req.catch(() => {
  }), e2;
}
function y(e2, t2 = {}) {
  let n2 = gt(ze(e2) ? { handler: e2 } : e2, t2), o2 = d(ze(e2) ? { handler: e2 } : e2, { ...t2, actualOp: "effect" }), l2 = V(o2);
  K(l2, "op", o2.kind = "effect"), o2.use = (e3) => (r(ze(e3), ".use argument should be a function"), g2.scope.handler = e3, o2), o2.use.getCurrent = () => g2.scope.handler;
  let s2 = o2.finally = d({ named: "finally", derived: 1 }), f2 = o2.done = s2.filterMap({ named: "done", fn({ status: e3, params: t3, result: r2 }) {
    if ("done" === e3)
      return { params: t3, result: r2 };
  } }), u2 = o2.fail = s2.filterMap({ named: "fail", fn({ status: e3, params: t3, error: r2 }) {
    if ("fail" === e3)
      return { params: t3, error: r2 };
  } }), c2 = o2.doneData = f2.map({ named: "doneData", fn: ({ result: e3 }) => e3 }), m2 = o2.failData = u2.map({ named: "failData", fn: ({ error: e3 }) => e3 }), g2 = a({ scope: { handlerId: J(l2, "sid"), handler: o2.defaultConfig.handler || (() => r(0, `no handler used in ${o2.getType()}`)) }, node: [Pe((e3, t3, r2) => {
    let n3 = t3, a2 = n3.handler;
    if (G(r2)) {
      let e4 = G(r2).handlers[n3.handlerId];
      e4 && (a2 = e4);
    }
    return e3.handler = a2, e3;
  }, 0, 1), Pe(({ params: e3, req: t3, handler: r2, args: n3 = [e3] }, a2, i2) => {
    let o3 = It(i2), l3 = Ot(e3, t3, 1, s2, i2, o3), f3 = Ot(e3, t3, 0, s2, i2, o3), [u3, d2] = At(r2, f3, n3);
    u3 && (xe(d2) && ze(d2.then) ? d2.then(l3, f3) : l3(d2));
  }, 0, 1)], meta: { op: "fx", fx: "runner" } });
  l2.scope.runner = g2, le(l2.seq, Pe((e3, { runner: t3 }, r2) => {
    let n3 = U(r2) ? { params: e3, req: { rs(e4) {
    }, rj(e4) {
    } } } : e3;
    return r2.meta || (r2.meta = { fxID: me() }), i({ target: t3, params: n3, defer: 1, scope: G(r2), meta: r2.meta }), n3.params;
  }, 0, 1)), o2.create = (e3) => {
    let t3 = h(), r2 = { params: e3, req: t3 };
    if (et && !rt) {
      let e4 = et;
      t3.req.finally(() => {
        ot(e4);
      }).catch(() => {
      });
    }
    return i({ target: o2, params: r2, scope: et }), t3.req;
  };
  let y2 = o2.inFlight = p(0, { serialize: "ignore" }).on(o2, (e3) => e3 + 1).on(s2, (e3) => e3 - 1).map({ fn: (e3) => e3, named: "inFlight" });
  K(s2, "needFxCounter", "dec"), K(o2, "needFxCounter", 1);
  let b2 = o2.pending = y2.map({ fn: (e3) => e3 > 0, named: "pending" });
  return we(o2, [s2, f2, u2, c2, m2, b2, y2]), null != n2 && n2.domain && n2.domain.hooks.effect(o2), o2;
}
function b(e2) {
  let t2;
  [e2, t2] = f(e2, 1);
  let { source: r2, effect: n2, mapParams: a2 } = e2, o2 = y(e2, t2);
  K(o2, "attached", 1);
  let l2, { runner: u2 } = V(o2).scope, d2 = Pe((e3, t3, n3) => {
    let l3, { params: s2, req: f2, handler: u3 } = e3, d3 = o2.finally, c3 = It(n3), p2 = Ot(s2, f2, 0, d3, n3, c3), m2 = n3.a, g2 = te(u3), h2 = 1;
    if (a2 ? [h2, l3] = At(a2, p2, [s2, m2]) : l3 = r2 && g2 ? m2 : s2, h2) {
      if (!g2)
        return e3.args = [m2, l3], 1;
      i({ target: u3, params: { params: l3, req: { rs: Ot(s2, f2, 1, d3, n3, c3), rj: p2 } }, page: n3.page, defer: 1, meta: n3.meta });
    }
  }, 1, 1);
  if (r2) {
    let e3;
    Z(r2) ? (e3 = r2, we(e3, [o2])) : (e3 = m(r2), we(o2, [e3])), l2 = [_e(B(e3)), d2];
  } else
    l2 = [d2];
  u2.seq.splice(1, 0, ...l2), o2.use(n2);
  let c2 = U(n2);
  return c2 && (Object.assign(Q(o2), s(o2.shortName, c2)), o2.defaultConfig.parent = c2), zt(n2, o2, "effect"), o2;
}
function v(...t2) {
  let [[r2, n2], a2] = f(t2), i2 = {};
  return e(n2, (e2, t3) => {
    let n3 = i2[t3] = d(t3, { parent: U(r2), config: a2 });
    r2.on(n3, e2), zt(r2, n3);
  }), i2;
}
function k(r2, n2) {
  let o2 = gt({ or: n2, and: "string" == typeof r2 ? { name: r2 } : r2 }), l2 = a({ family: { type: "domain" }, regional: 1, parent: (null == o2 ? void 0 : o2.domain) || (null == o2 ? void 0 : o2.parent) }), s2 = { history: {}, graphite: l2, hooks: {} };
  l2.meta = $t("domain", s2, { parent: (null == o2 ? void 0 : o2.domain) || (null == o2 ? void 0 : o2.parent), or: o2 }), e({ Event: d, Effect: y, Store: p, Domain: k }, (e2, r3) => {
    let n3 = r3.toLowerCase(), a2 = d({ named: `on${r3}` });
    s2.hooks[n3] = a2;
    let o3 = /* @__PURE__ */ new Set();
    s2.history[`${n3}s`] = o3, a2.create = (e3) => (i(a2, e3), e3), le(V(a2).seq, Pe((e3, t2, r4) => (r4.scope = null, e3))), a2.watch((e3) => {
      we(s2, [e3]), o3.add(e3), e3.ownerSet || (e3.ownerSet = o3), U(e3) || (e3.parent = s2);
    }), we(s2, [a2]), s2[`onCreate${r3}`] = (e3) => (t(o3, e3), a2.watch(e3)), s2[`create${r3}`] = s2[n3] = (t2, r4) => {
      let n4 = gt({ and: r4, or: t2 });
      return null != n4 && n4.domain ? e2(t2, r4) : a2(e2(t2, { parent: s2, or: n4 }));
    };
  });
  let f2 = U(s2);
  return f2 && e(s2.hooks, (e2, t2) => wt(e2, f2.hooks[t2])), null != o2 && o2.domain && o2.domain.hooks.domain(s2), s2;
}
function w(e2) {
  je(e2);
  let t2 = R in e2 ? e2[R]() : e2;
  r(t2.subscribe, "expect observable to have .subscribe");
  let n2 = d(), a2 = kt(n2);
  return t2.subscribe({ next: n2, error: a2, complete: a2 }), n2;
}
function S(e2, t2) {
  Me(e2, "merge", "first argument");
  let r2 = d({ name: o(e2, "merge"), derived: 1, and: t2 });
  return wt(e2, r2, [], "merge"), r2;
}
function x(e2, n2) {
  let a2 = 0;
  return t(Nt, (t2) => {
    t2 in e2 && (r(null != e2[t2], Ft(n2, t2)), a2 = 1);
  }), a2;
}
function z(...e2) {
  let t2, r2, n2, a2, [[i2, o2, l2], s2] = f(e2), u2 = 1;
  return $e(o2) && xe(i2) && x(i2, "sample") && (o2 = i2.clock, l2 = i2.fn, u2 = !i2.greedy, a2 = i2.filter, t2 = i2.target, r2 = i2.name, n2 = i2.sid, i2 = i2.source), Dt("sample", o2, i2, a2, t2, l2, r2, s2, u2, 1, 0, n2);
}
function $(...e2) {
  let [[t2, r2], n2] = f(e2);
  return r2 || (r2 = t2, t2 = r2.source), x(r2, "guard"), Dt("guard", r2.clock, t2, r2.filter, r2.target, null, r2.name, n2, !r2.greedy, 0, 1);
}
function j(t2, r2, n2) {
  if (Z(t2))
    return se(0, "restore($store)"), t2;
  if (ee(t2) || te(t2)) {
    let e2 = U(t2), a3 = p(r2, { parent: e2, name: t2.shortName, and: n2 });
    return wt(te(t2) ? t2.doneData : t2, a3), e2 && e2.hooks.store(a3), a3;
  }
  let a2 = Array.isArray(t2) ? [] : {};
  return e(t2, (e2, t3) => a2[t3] = Z(e2) ? e2 : p(e2, { name: t3 })), a2;
}
function C(...t2) {
  let n2, i2, o2 = "split", [[l2, s2], c2] = f(t2), p2 = !s2;
  p2 && (n2 = l2.cases, s2 = l2.match, i2 = l2.clock, l2 = l2.source);
  let m2 = Z(s2), g2 = !X(s2) && ze(s2), h2 = !m2 && !g2 && xe(s2);
  r(X(l2), "source must be a unit"), n2 || (n2 = {}), p2 ? e(n2, (e2, t3) => Ae(o2, e2, `cases.${t3}`)) : (r(h2, "match should be an object"), e(s2, (e2, t3) => n2[t3] = d({ derived: 1, and: c2 })), n2.__ = d({ derived: 1, and: c2 }));
  let y2, b2 = new Set([].concat(l2, i2 || [], Object.values(n2))), v2 = Object.keys(m2 || g2 ? n2 : s2);
  if (m2 || g2)
    m2 && b2.add(s2), y2 = [m2 && _e(B(s2), 0, 1), Ee({ safe: m2, filter: 1, pure: !m2, fn(e2, t3, r2) {
      let n3 = String(m2 ? r2.a : s2(e2));
      Pt(t3, ie(v2, n3) ? n3 : "__", e2, r2);
    } })];
  else if (h2) {
    let t3 = Te({});
    t3.type = "shape";
    let r2, n3 = [];
    e(s2, (e2, a2) => {
      if (X(e2)) {
        r2 = 1, le(n3, a2), b2.add(e2);
        let i3 = wt(e2, [], [_e(t3), Pe((e3, t4, { a: r3 }) => r3[a2] = e3)]);
        if (Z(e2)) {
          t3.current[a2] = e2.getState();
          let r3 = B(e2);
          We(t3, { from: r3, field: a2, type: "field" }), u("splitMatchStore", r3, i3);
        }
      }
    }), r2 && u("splitBase", t3), y2 = [r2 && _e(t3, 0, 1), Ve((e2, t4, r3) => {
      for (let a2 = 0; a2 < v2.length; a2++) {
        let i3 = v2[a2];
        if (ie(n3, i3) ? r3.a[i3] : s2[i3](e2))
          return void Pt(t4, i3, e2, r3);
      }
      Pt(t4, "__", e2, r3);
    }, 1)];
  } else
    r(0, "expect match to be unit, function or object");
  let k2 = a({ meta: { op: o2 }, parent: i2 ? [] : l2, scope: n2, node: y2, family: { owners: Array.from(b2) }, regional: 1 });
  if (i2 && Dt(o2, i2, l2, null, k2, null, o2, c2, 0, 0, 0), !p2)
    return n2;
}
function M(e2, { scope: t2, params: r2 } = {}) {
  if (!X(e2))
    return Promise.reject(new Error("first argument should be unit"));
  if (!(te(e2) || ee(e2) || Z(e2) || ne(e2)))
    return Promise.reject(new Error("first argument accepts only effects, events, stores or scopes"));
  ne(e2) && (t2 = e2);
  let n2 = h();
  n2.parentFork = et;
  let { fxCount: a2 } = t2;
  le(a2.scope.defers, n2);
  let o2 = [], l2 = [];
  return ne(e2) || (le(o2, e2), le(l2, te(e2) ? { params: r2, req: { rs(e3) {
    n2.value = { status: "done", value: e3 };
  }, rj(e3) {
    n2.value = { status: "fail", value: e3 };
  } } } : r2)), le(o2, a2), le(l2, null), i({ target: o2, params: l2, scope: t2 }), n2.req;
}
function A(e2, r2) {
  let n2 = [];
  (function e3(a2) {
    ie(n2, a2) || (le(n2, a2), "store" === J(a2, "op") && J(a2, "sid") && r2(a2, J(a2, "sid")), t(a2.next, e3), t(L(a2), e3), t(T(a2), e3));
  })(e2);
}
function I(e2, n2) {
  let a2 = Array.isArray(e2) ? new Map(e2) : e2;
  if (a2 instanceof Map) {
    let e3 = {};
    return t(a2, (t2, a3) => {
      r(X(a3), "Map key should be a unit"), n2 && n2(a3, t2), r(a3.sid, "unit should have a sid"), r(!(a3.sid in e3), "duplicate sid found"), e3[a3.sid] = t2;
    }), e3;
  }
  return a2;
}
function O(e2, n2) {
  let i2, o2 = e2;
  re(e2) && (i2 = e2, o2 = n2);
  let l2 = ((e3) => {
    let r2 = a({ scope: { defers: [], inFlight: 0, fxID: 0 }, node: [Pe((e4, t2, r3) => {
      U(r3) ? "dec" === J(U(r3).node, "needFxCounter") ? t2.inFlight -= 1 : (t2.inFlight += 1, t2.fxID += 1) : t2.fxID += 1;
    }), Ee({ priority: "sampler", batch: 1 }), Pe((e4, r3) => {
      let { defers: n4, fxID: a2 } = r3;
      r3.inFlight > 0 || 0 === n4.length || Promise.resolve().then(() => {
        r3.fxID === a2 && t(n4.splice(0, n4.length), (e5) => {
          ot(e5.parentFork), e5.rs(e5.value);
        });
      });
    }, 0, 1)] }), n3 = a({ node: [Pe((e4, t2, r3) => {
      let n4 = U(r3);
      if (n4) {
        let t3 = n4.node;
        if (!J(t3, "isCombine") || U(n4) && "combine" !== J(U(n4).node, "op")) {
          let n5 = G(r3), a2 = t3.scope.state.id, i4 = J(t3, "sid");
          n5.sidIdMap[i4] = a2, n5.sidValuesMap[i4] = e4;
          let o4 = J(t3, "serialize");
          o4 && n5.sidSerializeSettings.set(i4, "ignore" === o4 ? { ignore: 1 } : { ignore: 0, write: o4.write });
        }
      }
    })] }), i3 = a({ node: [Pe((e4, t2, r3) => {
      let n4 = G(r3);
      if (n4) {
        let e5 = U(r3);
        e5 && (!J(e5.node, "isCombine") || U(e5) && "combine" !== J(U(e5).node, "op")) && (n4.warnSerialize = 1);
      }
    })] }), o3 = { cloneOf: e3, reg: {}, sidValuesMap: {}, sidIdMap: {}, sidSerializeSettings: /* @__PURE__ */ new Map(), getState(e4) {
      if ("current" in e4)
        return ut(at, o3, null, e4).current;
      let t2 = V(e4);
      return ut(at, o3, t2, t2.scope.state, 1).current;
    }, kind: "scope", graphite: a({ family: { type: "domain", links: [r2, n3, i3] }, meta: { unit: "fork" }, scope: { forkInFlightCounter: r2 } }), additionalLinks: {}, handlers: {}, fxCount: r2, storeChange: n3, warnSerializeNode: i3, activeEffects: [] };
    return o3;
  })(i2);
  if (o2) {
    let e3 = o2.scope;
    if (e3) {
      let r2 = e3.activeEffects;
      e3.activeEffects = [], l2.activeEffects = r2, t(r2, (e4) => e4.ref = l2);
    }
    if (o2.values) {
      let e4 = I(o2.values, (e5) => r(Z(e5), "Values map can contain only stores as keys"));
      Object.assign(l2.sidValuesMap, e4), l2.fromSerialize = !(Array.isArray(o2.values) || o2.values instanceof Map);
    }
    o2.handlers && (l2.handlers = I(o2.handlers, (e4) => r(te(e4), "Handlers map can contain only effects as keys")));
  }
  return l2;
}
function q(e2, { values: t2 }) {
  r(xe(t2), "values property should be an object");
  let n2, a2, o2, l2 = I(t2), s2 = Object.getOwnPropertyNames(l2), f2 = [], u2 = [];
  ne(e2) ? (n2 = e2, o2 = 1, r(n2.cloneOf, "scope should be created from domain"), a2 = V(n2.cloneOf)) : re(e2) ? a2 = V(e2) : r(0, "first argument of hydrate should be domain or scope"), A(a2, (e3, t3) => {
    if (ie(s2, t3)) {
      le(f2, e3);
      let r2 = J(e3, "serialize");
      r2 && "ignore" !== r2 && (l2[t3] = r2.read(l2[t3])), le(u2, l2[t3]);
    }
  }), i({ target: f2, params: u2, scope: n2 }), o2 && Object.assign(n2.sidValuesMap, l2);
}
function N(e2, { scope: t2, safe: n2 } = {}) {
  r(t2 || et || n2, "scopeBind cannot be called outside of forked .watch");
  let a2 = t2 || et;
  return te(e2) ? (t3) => {
    let r2 = h();
    return i({ target: e2, params: { params: t3, req: r2 }, scope: a2 }), r2.req;
  } : (t3) => (i({ target: e2, params: t3, scope: a2 }), t3);
}
function F(t2, n2 = {}) {
  t2.warnSerialize && console.error("There is a store without sid in this scope, its value is omitted");
  let a2 = n2.ignore ? n2.ignore.map(({ sid: e2 }) => e2) : [], i2 = {};
  return e(t2.sidValuesMap, (e2, r2) => {
    var n3;
    if (ie(a2, r2))
      return;
    let o2 = t2.sidIdMap[r2], l2 = null !== (n3 = t2.sidSerializeSettings.get(r2)) && void 0 !== n3 ? n3 : { ignore: 0, write: Vt };
    l2.ignore || (i2[r2] = (0, l2.write)(o2 && o2 in t2.reg ? t2.reg[o2].current : e2));
  }), "onlyChanges" in n2 && !n2.onlyChanges && (r(t2.cloneOf, "scope should be created from domain"), A(V(t2.cloneOf), (e2, r2) => {
    r2 in i2 || ie(a2, r2) || J(e2, "isCombine") || "ignore" === J(e2, "serialize") || (i2[r2] = t2.getState(e2));
  })), i2;
}
function D({ unit: e2, fn: t2, scope: r2 }) {
  let n2 = [Le.run({ fn: (e3) => t2(e3) })];
  if (r2) {
    let t3 = a({ node: n2 }), i2 = e2.graphite.id, o2 = r2.additionalLinks, l2 = o2[i2] || [];
    return o2[i2] = l2, l2.push(t3), E(() => {
      let e3 = l2.indexOf(t3);
      -1 !== e3 && l2.splice(e3, 1), vt(t3);
    });
  }
  {
    let t3 = a({ node: n2, parent: [e2], family: { owners: e2 } });
    return E(() => {
      vt(t3);
    });
  }
}
function E(e2) {
  let t2 = () => e2();
  return t2.unsubscribe = () => e2(), t2;
}
var R = "undefined" != typeof Symbol && Symbol.observable || "@@observable";
var P = "map";
var _ = "stack";
var V = (e2) => e2.graphite || e2;
var L = (e2) => e2.family.owners;
var T = (e2) => e2.family.links;
var B = (e2) => e2.stateRef;
var W = (e2) => e2.value;
var H = (e2) => e2.subscribers;
var U = (e2) => e2.parent;
var G = (e2) => e2.scope;
var J = (e2, t2) => V(e2).meta[t2];
var K = (e2, t2, r2) => V(e2).meta[t2] = r2;
var Q = (e2) => e2.compositeName;
var X = (e2) => (ze(e2) || xe(e2)) && "kind" in e2;
var Y = (e2) => (t2) => X(t2) && t2.kind === e2;
var Z = Y("store");
var ee = Y("event");
var te = Y("effect");
var re = Y("domain");
var ne = Y("scope");
var ae = { __proto__: null, unit: X, store: Z, event: ee, effect: te, domain: re, scope: ne, attached: (e2) => te(e2) && 1 == J(e2, "attached") };
var ie = (e2, t2) => e2.includes(t2);
var oe = (e2, t2) => {
  let r2 = e2.indexOf(t2);
  -1 !== r2 && e2.splice(r2, 1);
};
var le = (e2, t2) => e2.push(t2);
var se = (e2, t2, r2) => !e2 && console.error(`${t2} is deprecated${r2 ? `, use ${r2} instead` : ""}`);
var fe = () => {
  let e2 = 0;
  return () => "" + ++e2;
};
var ue;
var de = fe();
var ce = fe();
var pe = fe();
var me = fe();
var ge = (e2) => {
  ue = e2;
};
var he = null;
var ye = (e2) => {
  ue && ue(e2, he);
};
var be = () => he && he.template;
var ve = (e2) => (e2 && he && he.sidRoot && (e2 = `${he.sidRoot}|${e2}`), e2);
var ke = ({ sid: e2, name: t2, loc: r2, method: i2, fn: o2 }) => n(a({ meta: { sidRoot: ve(e2), sid: e2, name: t2, loc: r2, method: i2, type: "factory" } }), o2);
var we = (e2, r2) => {
  let n2 = V(e2);
  t(r2, (e3) => {
    let t2 = V(e3);
    "domain" !== n2.family.type && (t2.family.type = "crosslink"), le(L(t2), n2), le(T(n2), t2);
  });
};
var Se = (e2 = []) => (Array.isArray(e2) ? e2 : [e2]).flat().map(V);
var xe = (e2) => "object" == typeof e2 && null !== e2;
var ze = (e2) => "function" == typeof e2;
var $e = (e2) => void 0 === e2;
var je = (e2) => r(xe(e2) || ze(e2), "expect first argument be an object");
var Ce = (e2, t2, n2, a2) => r(!(!xe(e2) && !ze(e2) || !("family" in e2) && !("graphite" in e2)), `${t2}: expect ${n2} to be a unit (store, event or effect)${a2}`);
var Me = (e2, r2, n2) => {
  Array.isArray(e2) ? t(e2, (e3, t2) => Ce(e3, r2, `${t2} item of ${n2}`, "")) : Ce(e2, r2, n2, " or array of units");
};
var Ae = (e2, r2, n2 = "target") => t(Se(r2), (t2) => se(!J(t2, "derived"), `${e2}: derived unit in "${n2}"`, "createEvent/createStore"));
var Ie = (e2, { fn: t2 }, { a: r2 }) => t2(e2, r2);
var Oe = (e2, { fn: t2 }, { a: r2 }) => t2(r2, e2);
var qe = (e2, { fn: t2 }) => t2(e2);
var Ne = (e2, t2, r2, n2) => {
  let a2 = { id: ce(), type: e2, data: t2 };
  return r2 && (a2.order = { priority: r2 }, n2 && (a2.order.barrierID = ++Fe)), a2;
};
var Fe = 0;
var De = ({ from: e2 = "store", store: t2, target: r2, to: n2 = r2 ? "store" : _, batch: a2, priority: i2 }) => Ne("mov", { from: e2, store: t2, to: n2, target: r2 }, i2, a2);
var Ee = ({ fn: e2, batch: t2, priority: r2, safe: n2 = 0, filter: a2 = 0, pure: i2 = 0 }) => Ne("compute", { fn: e2, safe: n2, filter: a2, pure: i2 }, r2, t2);
var Re = ({ fn: e2 }) => Ee({ fn: e2, priority: "effect" });
var Pe = (e2, t2, r2) => Ee({ fn: e2, safe: 1, filter: t2, priority: r2 && "effect" });
var _e = (e2, t2, r2) => De({ store: e2, to: t2 ? _ : "a", priority: r2 && "sampler", batch: 1 });
var Ve = (e2 = qe, t2) => Ee({ fn: e2, pure: 1, filter: t2 });
var Le = { mov: De, compute: Ee, filter: ({ fn: e2, pure: t2 }) => Ee({ fn: e2, filter: 1, pure: t2 }), run: Re };
var Te = (e2) => ({ id: ce(), current: e2 });
var Be = ({ current: e2 }) => e2;
var We = (e2, t2) => {
  e2.before || (e2.before = []), le(e2.before, t2);
};
var He = null;
var Ue = (e2, t2) => {
  if (!e2)
    return t2;
  if (!t2)
    return e2;
  let r2;
  return (e2.v.type === t2.v.type && e2.v.id > t2.v.id || Ye(e2.v.type) > Ye(t2.v.type)) && (r2 = e2, e2 = t2, t2 = r2), r2 = Ue(e2.r, t2), e2.r = e2.l, e2.l = r2, e2;
};
var Ge = [];
var Je = 0;
for (; Je < 6; )
  le(Ge, { first: null, last: null, size: 0 }), Je += 1;
var Ke = () => {
  for (let e2 = 0; e2 < 6; e2++) {
    let t2 = Ge[e2];
    if (t2.size > 0) {
      if (3 === e2 || 4 === e2) {
        t2.size -= 1;
        let e3 = He.v;
        return He = Ue(He.l, He.r), e3;
      }
      1 === t2.size && (t2.last = null);
      let r2 = t2.first;
      return t2.first = r2.r, t2.size -= 1, r2.v;
    }
  }
};
var Qe = (e2, t2, r2, n2, a2, i2, o2) => Xe(0, { a: null, b: null, node: r2, parent: n2, value: a2, page: t2, scope: i2, meta: o2 }, e2);
var Xe = (e2, t2, r2, n2 = 0) => {
  let a2 = Ye(r2), i2 = Ge[a2], o2 = { v: { idx: e2, stack: t2, type: r2, id: n2 }, l: null, r: null };
  3 === a2 || 4 === a2 ? He = Ue(He, o2) : (0 === i2.size ? i2.first = o2 : i2.last.r = o2, i2.last = o2), i2.size += 1;
};
var Ye = (e2) => {
  switch (e2) {
    case "child":
      return 0;
    case "pure":
      return 1;
    case "read":
      return 2;
    case "barrier":
      return 3;
    case "sampler":
      return 4;
    case "effect":
      return 5;
    default:
      return -1;
  }
};
var Ze = /* @__PURE__ */ new Set();
var et;
var tt = 1;
var rt = 0;
var nt = 0;
var at = null;
var ot = (e2) => {
  et = e2;
};
var lt = (e2) => {
  at = e2;
};
var st = (e2, t2) => {
  if (e2) {
    for (; e2 && !e2.reg[t2]; )
      e2 = U(e2);
    if (e2)
      return e2;
  }
  return null;
};
var ft;
var ut = (e2, t2, r2, n2, a2) => {
  let i2 = st(e2, n2.id);
  return i2 ? i2.reg[n2.id] : t2 ? (pt(t2, n2, a2), t2.reg[n2.id]) : n2;
};
var dt = (e2) => {
  ft = e2;
};
var ct = (e2) => e2;
var pt = (e2, r2, n2, a2, i2) => {
  var o2;
  let l2 = e2.reg, s2 = r2.sid, f2 = null == r2 || null === (o2 = r2.meta) || void 0 === o2 ? void 0 : o2.serialize;
  if (l2[r2.id])
    return;
  let u2 = { id: r2.id, current: r2.current, meta: r2.meta };
  if (s2 && s2 in e2.sidValuesMap && !(s2 in e2.sidIdMap))
    u2.current = (e2.fromSerialize && "ignore" !== f2 && (null == f2 ? void 0 : f2.read) || ct)(e2.sidValuesMap[s2]);
  else if (r2.before && !i2) {
    let i3 = 0, o3 = n2 || !r2.noInit || a2;
    t(r2.before, (t2) => {
      switch (t2.type) {
        case P: {
          let r3 = t2.from;
          if (r3 || t2.fn) {
            r3 && pt(e2, r3, n2, a2);
            let i4 = r3 && l2[r3.id].current;
            o3 && (u2.current = t2.fn ? t2.fn(i4) : i4);
          }
          break;
        }
        case "field":
          i3 || (i3 = 1, u2.current = Array.isArray(u2.current) ? [...u2.current] : { ...u2.current }), pt(e2, t2.from, n2, a2), o3 && (u2.current[t2.field] = l2[l2[t2.from.id].id].current);
      }
    });
  }
  s2 && (e2.sidIdMap[s2] = r2.id), l2[r2.id] = u2;
};
var mt = (e2, t2, r2) => {
  try {
    return t2(W(r2), e2.scope, r2);
  } catch (t3) {
    console.error(t3), e2.fail = 1, e2.failReason = t3;
  }
};
var gt = (t2, r2 = {}) => (xe(t2) && (gt(t2.or, r2), e(t2, (e2, t3) => {
  $e(e2) || "or" === t3 || "and" === t3 || (r2[t3] = e2);
}), gt(t2.and, r2)), r2);
var ht = (e2, t2) => {
  oe(e2.next, t2), oe(L(e2), t2), oe(T(e2), t2);
};
var yt = (e2, t2, r2) => {
  let n2;
  e2.next.length = 0, e2.seq.length = 0, e2.scope = null;
  let a2 = T(e2);
  for (; n2 = a2.pop(); )
    ht(n2, e2), (t2 || r2 && "sample" !== J(e2, "op") || "crosslink" === n2.family.type) && yt(n2, t2, "on" !== J(n2, "op") && r2);
  for (a2 = L(e2); n2 = a2.pop(); )
    ht(n2, e2), r2 && "crosslink" === n2.family.type && yt(n2, t2, "on" !== J(n2, "op") && r2);
};
var bt = (e2) => e2.clear();
var vt = (e2, { deep: t2 } = {}) => {
  let r2 = 0;
  if (e2.ownerSet && e2.ownerSet.delete(e2), Z(e2))
    bt(H(e2));
  else if (re(e2)) {
    r2 = 1;
    let t3 = e2.history;
    bt(t3.events), bt(t3.effects), bt(t3.stores), bt(t3.domains);
  }
  yt(V(e2), !!t2, r2);
};
var kt = (e2) => {
  let t2 = () => vt(e2);
  return t2.unsubscribe = t2, t2;
};
var wt = (e2, t2, r2, n2, i2) => a({ node: r2, parent: e2, child: t2, scope: { fn: i2 }, meta: { op: n2 }, family: { owners: [e2, t2], links: t2 }, regional: 1 });
var St = (e2) => {
  let t2 = "forward", [{ from: r2, to: n2 }, i2] = f(e2, 1);
  return Me(r2, t2, '"from"'), Me(n2, t2, '"to"'), Ae(t2, n2, "to"), kt(a({ parent: r2, child: n2, meta: { op: t2, config: i2 }, family: {}, regional: 1 }));
};
var xt = (e2, t2) => (r(ze(t2), ".watch argument should be a function"), kt(a({ scope: { fn: t2 }, node: [Re({ fn: qe })], parent: e2, meta: { op: "watch" }, family: { owners: e2 }, regional: 1 })));
var zt = (e2, t2, r2 = "event") => {
  U(e2) && U(e2).hooks[r2](t2);
};
var $t = (e2, t2, r2) => {
  let n2 = gt(r2), a2 = "domain" === e2, i2 = de(), { sid: o2 = null, named: l2 = null, domain: f2 = null, parent: u2 = f2 } = n2, d2 = l2 || n2.name || (a2 ? "" : i2), c2 = s(d2, u2), p2 = { op: t2.kind = e2, name: t2.shortName = d2, sid: t2.sid = ve(o2), named: l2, unitId: t2.id = i2, serialize: n2.serialize, derived: n2.derived, config: n2 };
  if (t2.parent = u2, t2.compositeName = c2, t2.defaultConfig = n2, t2.thru = (e3) => (se(0, "thru", "js pipe"), e3(t2)), t2.getType = () => c2.fullName, !a2) {
    t2.subscribe = (e4) => (je(e4), t2.watch(ze(e4) ? e4 : (t3) => e4.next && e4.next(t3))), t2[R] = () => t2;
    let e3 = be();
    e3 && (p2.nativeTemplate = e3);
  }
  return p2;
};
var jt = (e2, t2, r2, n2) => {
  let a2;
  xe(r2) && (a2 = r2, r2 = r2.fn);
  let i2 = d({ name: `${e2.shortName} → *`, derived: 1, and: a2 });
  return wt(e2, i2, n2, t2, r2), i2;
};
var Ct = (e2, t2, r2, n2, a2) => {
  let i2 = B(t2), o2 = De({ store: i2, to: "a", priority: "read" });
  r2 === P && (o2.data.softRead = 1);
  let l2 = [o2, Ve(n2)];
  return u("storeOnMap", i2, l2, Z(e2) && B(e2)), wt(e2, t2, l2, r2, a2);
};
var Mt = (t2, n2, a2, i2, l2) => {
  let s2 = t2 ? (e2) => [...e2] : (e2) => ({ ...e2 }), f2 = t2 ? [] : {}, d2 = s2(f2), c2 = Te(d2), m2 = Te(1);
  c2.type = t2 ? "list" : "shape", c2.noInit = 1, u("combineBase", c2, m2);
  let g2 = p(d2, { name: o(a2), derived: 1, and: i2 }), h2 = B(g2);
  h2.noInit = 1, K(g2, "isCombine", 1);
  let y2 = _e(c2);
  y2.order = { priority: "barrier" };
  let b2 = [Pe((e2, t3, r2) => (r2.scope && !r2.scope.reg[c2.id] && (r2.c = 1), e2)), y2, De({ store: m2, to: "b" }), Pe((e2, { key: t3 }, r2) => {
    if (r2.c || e2 !== r2.a[t3])
      return n2 && r2.b && (r2.a = s2(r2.a)), r2.a[t3] = e2, 1;
  }, 1), De({ from: "a", target: c2 }), De({ from: "value", store: 0, target: m2 }), De({ from: "value", store: 1, target: m2, priority: "barrier", batch: 1 }), _e(c2, 1), l2 && Ve()];
  return e(a2, (e2, t3) => {
    if (!Z(e2))
      return r(!X(e2) && !$e(e2), `combine expects a store in a field ${t3}`), void (d2[t3] = f2[t3] = e2);
    f2[t3] = e2.defaultState, d2[t3] = e2.getState();
    let n3 = wt(e2, g2, b2, "combine", l2);
    n3.scope.key = t3;
    let a3 = B(e2);
    We(c2, { type: "field", field: t3, from: a3 }), u("combineField", a3, n3);
  }), g2.defaultShape = a2, We(h2, { type: P, from: c2, fn: l2 }), be() || (g2.defaultState = l2 ? h2.current = l2(d2) : f2), g2;
};
var At = (e2, t2, r2) => {
  try {
    return [1, e2(...r2)];
  } catch (e3) {
    return t2(e3), [0, null];
  }
};
var It = (e2) => {
  let t2 = G(e2), r2 = { ref: t2 };
  return t2 && le(t2.activeEffects, r2), r2;
};
var Ot = (e2, t2, r2, n2, a2, o2) => (l2) => {
  o2.ref && oe(o2.ref.activeEffects, o2), i({ target: [n2, qt], params: [r2 ? { status: "done", params: e2, result: l2 } : { status: "fail", params: e2, error: l2 }, { value: l2, fn: r2 ? t2.rs : t2.rj }], defer: 1, page: a2.page, scope: o2.ref, meta: a2.meta });
};
var qt = a({ node: [Re({ fn: ({ fn: e2, value: t2 }) => e2(t2) })], meta: { op: "fx", fx: "sidechain" } });
var Nt = ["source", "clock", "target"];
var Ft = (e2, t2) => e2 + `: ${t2} should be defined`;
var Dt = (e2, t2, n2, a2, i2, o2, l2, s2, f2, c2, g2, h2) => {
  let y2 = !!i2;
  r(!$e(n2) || !$e(t2), Ft(e2, "either source or clock"));
  let b2 = 0;
  $e(n2) ? b2 = 1 : X(n2) || (n2 = m(n2)), $e(t2) ? t2 = n2 : (Me(t2, e2, "clock"), Array.isArray(t2) && (t2 = S(t2))), b2 && (n2 = t2), s2 || l2 || (l2 = n2.shortName);
  let v2 = "none";
  (g2 || a2) && (X(a2) ? v2 = "unit" : (r(ze(a2), "`filter` should be function or unit"), v2 = "fn")), i2 ? (Me(i2, e2, "target"), Ae(e2, i2)) : "none" === v2 && c2 && Z(n2) && Z(t2) ? i2 = p(o2 ? o2(Be(B(n2)), Be(B(t2))) : Be(B(n2)), { name: l2, sid: h2, or: s2 }) : (i2 = d({ name: l2, derived: 1, or: s2 }), u("sampleTarget", V(i2)));
  let k2 = Te(), w2 = [];
  if ("unit" === v2) {
    let [r2, n3] = Rt(a2, i2, t2, k2, e2);
    w2 = [...Et(n3), ...Et(r2)];
  }
  let [x2, z2] = Rt(n2, i2, t2, k2, e2), $2 = wt(t2, i2, [u("sampleSourceLoader"), De({ from: _, target: k2 }), ...Et(z2), _e(x2, 1, f2), ...w2, _e(k2), "fn" === v2 && Ve((e3, t3, { a: r2 }) => a2(e3, r2), 1), o2 && Ve(Ie), u("sampleSourceUpward", y2)], e2, o2);
  return we(n2, [$2]), Object.assign($2.meta, s2, { joint: 1 }), i2;
};
var Et = (e2) => [_e(e2), Pe((e3, t2, { a: r2 }) => r2, 1)];
var Rt = (e2, t2, r2, n2, i2) => {
  let o2 = Z(e2), l2 = o2 ? B(e2) : Te(), s2 = Te(o2);
  return o2 || a({ parent: e2, node: [De({ from: _, target: l2 }), De({ from: "value", store: 1, target: s2 })], family: { owners: [e2, t2, r2], links: t2 }, meta: { op: i2 }, regional: 1 }), u("sampleSource", s2, l2, n2), [l2, s2];
};
var Pt = (e2, t2, r2, n2) => {
  let a2 = e2[t2];
  a2 && i({ target: a2, params: Array.isArray(a2) ? a2.map(() => r2) : r2, defer: 1, stack: n2 });
};
var _t = "22.7.0";
var Vt = (e2) => e2;

export {
  n,
  a,
  i,
  l,
  d,
  p,
  m,
  g,
  y,
  b,
  v,
  k,
  w,
  S,
  z,
  $,
  j,
  C,
  M,
  O,
  q,
  N,
  F,
  D,
  ae,
  ge,
  ke,
  Le,
  dt,
  vt,
  St,
  _t
};
//# sourceMappingURL=chunk-5OLYA55J.js.map
